{"name": "Переход в ЛК по клику на кнопку «Личный кабинет»", "status": "broken", "statusDetails": {"message": "RecursionError: maximum recursion depth exceeded", "trace": "self = <web_pages.UIWorkerWeb object at 0x000002A44807BD70>\nlocator = ('xpath', \".//label[text()='Email']//parent::*/input[@type='text' and @name='name']\")\n\n    @allure.step('Дождаться кликабельности элемента')\n    def wait_for_element_to_be_clickable(self, locator):\n>       BasePage.wait_for_element_to_be_clickable(self, locator)\n\nweb_pages\\base_page.py:64: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nvenv\\Lib\\site-packages\\allure_commons\\_allure.py:179: in __enter__\n    plugin_manager.hook.start_step(uuid=self.uuid, title=self.title, params=self.params)\nvenv\\Lib\\site-packages\\allure_pytest\\listener.py:50: in start_step\n    self.allure_logger.start_step(None, uuid, step)\nvenv\\Lib\\site-packages\\allure_commons\\reporter.py:128: in start_step\n    parent_uuid = parent_uuid if parent_uuid else self._last_executable()\nvenv\\Lib\\site-packages\\allure_commons\\reporter.py:71: in _last_executable\n    for _uuid in reversed(self._items):\nvenv\\Lib\\site-packages\\allure_commons\\reporter.py:39: in __reversed__\n    return self.thread_context.__reversed__()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <allure_commons.reporter.ThreadContextItems object at 0x000002A448039BE0>\n\n    @property\n    def thread_context(self):\n>       context = self._thread_context[threading.current_thread()]\nE       RecursionError: maximum recursion depth exceeded\n\nvenv\\Lib\\site-packages\\allure_commons\\reporter.py:19: RecursionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <web_pages.UIWorkerWeb object at 0x000002A44807BD70>\nlocator = ('xpath', \".//label[text()='Email']//parent::*/input[@type='text' and @name='name']\")\n\n    @allure.step('Дождаться кликабельности элемента')\n    def wait_for_element_to_be_clickable(self, locator):\n>       BasePage.wait_for_element_to_be_clickable(self, locator)\n\nweb_pages\\base_page.py:64: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nvenv\\Lib\\site-packages\\allure_commons\\_allure.py:182: in __exit__\n    plugin_manager.hook.stop_step(uuid=self.uuid, title=self.title, exc_type=exc_type, exc_val=exc_val,\nvenv\\Lib\\site-packages\\allure_pytest\\listener.py:57: in stop_step\n    statusDetails=get_status_details(exc_type, exc_val, exc_tb))\nvenv\\Lib\\site-packages\\allure_pytest\\utils.py:174: in get_status_details\n    message = format_exception(exception_type, exception)\nvenv\\Lib\\site-packages\\allure_commons\\utils.py:323: in format_exception\n    return '\\n'.join(format_exception_only(etype, value)) if etype or value else None\n..\\..\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\traceback.py:157: in format_exception_only\n    return list(te.format_exception_only())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <traceback.TracebackException object at 0x000002A4482DB140>\n\n    def format_exception_only(self):\n        \"\"\"Format the exception part of the traceback.\n    \n        The return value is a generator of strings, each ending in a newline.\n    \n        Generator yields the exception message.\n        For :exc:`SyntaxError` exceptions, it\n        also yields (before the exception message)\n        several lines that (when printed)\n        display detailed information about where the syntax error occurred.\n        Following the message, generator also yields\n        all the exception's ``__notes__``.\n        \"\"\"\n        if self.exc_type is None:\n            yield _format_final_exc_line(None, self._str)\n            return\n    \n        stype = self.exc_type.__qualname__\n        smod = self.exc_type.__module__\n        if smod not in (\"__main__\", \"builtins\"):\n            if not isinstance(smod, str):\n                smod = \"<unknown>\"\n            stype = smod + '.' + stype\n    \n        if not issubclass(self.exc_type, SyntaxError):\n            yield _format_final_exc_line(stype, self._str)\n        else:\n            yield from self._format_syntax_error(stype)\n    \n        if (\n>           isinstance(self.__notes__, collections.abc.Sequence)\n            and not isinstance(self.__notes__, (str, bytes))\n        ):\nE       RecursionError: maximum recursion depth exceeded\n\n..\\..\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\traceback.py:899: RecursionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <web_pages.UIWorkerWeb object at 0x000002A44807BD70>\nlocator = ('xpath', \".//label[text()='Email']//parent::*/input[@type='text' and @name='name']\")\n\n    @allure.step('Дождаться кликабельности элемента')\n    def wait_for_element_to_be_clickable(self, locator):\n>       BasePage.wait_for_element_to_be_clickable(self, locator)\n\nweb_pages\\base_page.py:64: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nvenv\\Lib\\site-packages\\allure_commons\\_allure.py:182: in __exit__\n    plugin_manager.hook.stop_step(uuid=self.uuid, title=self.title, exc_type=exc_type, exc_val=exc_val,\nvenv\\Lib\\site-packages\\allure_pytest\\listener.py:57: in stop_step\n    statusDetails=get_status_details(exc_type, exc_val, exc_tb))\nvenv\\Lib\\site-packages\\allure_pytest\\utils.py:174: in get_status_details\n    message = format_exception(exception_type, exception)\nvenv\\Lib\\site-packages\\allure_commons\\utils.py:323: in format_exception\n    return '\\n'.join(format_exception_only(etype, value)) if etype or value else None\n..\\..\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\traceback.py:156: in format_exception_only\n    te = TracebackException(type(value), value, None, compact=True)\n..\\..\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\traceback.py:811: in __init__\n    context = TracebackException(\n..\\..\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\traceback.py:733: in __init__\n    self.stack = StackSummary._extract_from_extended_frame_gen(\n..\\..\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\traceback.py:438: in _extract_from_extended_frame_gen\n    f.line\n..\\..\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\traceback.py:323: in line\n    self._line = linecache.getline(self.filename, self.lineno)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfilename = 'C:\\\\Users\\\\User\\\\Diplom\\\\Diplom_3\\\\venv\\\\Lib\\\\site-packages\\\\allure_commons\\\\_allure.py', lineno = 192, module_globals = None\n\n    def getline(filename, lineno, module_globals=None):\n        \"\"\"Get a line for a Python source file from the cache.\n        Update the cache if it doesn't contain an entry for this file already.\"\"\"\n    \n>       lines = getlines(filename, module_globals)\nE       RecursionError: maximum recursion depth exceeded\n\n..\\..\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\linecache.py:30: RecursionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <web_pages.UIWorkerWeb object at 0x000002A44807BD70>\nlocator = ('xpath', \".//label[text()='Email']//parent::*/input[@type='text' and @name='name']\")\n\n    @allure.step('Дождаться кликабельности элемента')\n    def wait_for_element_to_be_clickable(self, locator):\n>       BasePage.wait_for_element_to_be_clickable(self, locator)\n\nweb_pages\\base_page.py:64: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nvenv\\Lib\\site-packages\\allure_commons\\_allure.py:182: in __exit__\n    plugin_manager.hook.stop_step(uuid=self.uuid, title=self.title, exc_type=exc_type, exc_val=exc_val,\nvenv\\Lib\\site-packages\\allure_pytest\\listener.py:57: in stop_step\n    statusDetails=get_status_details(exc_type, exc_val, exc_tb))\nvenv\\Lib\\site-packages\\allure_pytest\\utils.py:174: in get_status_details\n    message = format_exception(exception_type, exception)\nvenv\\Lib\\site-packages\\allure_commons\\utils.py:323: in format_exception\n    return '\\n'.join(format_exception_only(etype, value)) if etype or value else None\n..\\..\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\traceback.py:156: in format_exception_only\n    te = TracebackException(type(value), value, None, compact=True)\n..\\..\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\traceback.py:811: in __init__\n    context = TracebackException(\n..\\..\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\traceback.py:733: in __init__\n    self.stack = StackSummary._extract_from_extended_frame_gen(\n..\\..\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\traceback.py:438: in _extract_from_extended_frame_gen\n    f.line\n..\\..\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\traceback.py:323: in line\n    self._line = linecache.getline(self.filename, self.lineno)\n..\\..\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\linecache.py:30: in getline\n    lines = getlines(filename, module_globals)\n..\\..\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\linecache.py:46: in getlines\n    return updatecache(filename, module_globals)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfilename = 'C:\\\\Users\\\\User\\\\Diplom\\\\Diplom_3\\\\venv\\\\Lib\\\\site-packages\\\\allure_commons\\\\_allure.py', module_globals = None\n\n    def updatecache(filename, module_globals=None):\n        \"\"\"Update a cache entry and return its list of lines.\n        If something's wrong, print a message, discard the cache entry,\n        and return an empty list.\"\"\"\n    \n        if filename in cache:\n            if len(cache[filename]) != 1:\n                cache.pop(filename, None)\n        if not filename or (filename.startswith('<') and filename.endswith('>')):\n            return []\n    \n        fullname = filename\n        try:\n            stat = os.stat(fullname)\n        except OSError:\n            basename = filename\n    \n            # Realise a lazy loader based lookup if there is one\n            # otherwise try to lookup right now.\n            if lazycache(filename, module_globals):\n                try:\n                    data = cache[filename][0]()\n                except (ImportError, OSError):\n                    pass\n                else:\n                    if data is None:\n                        # No luck, the PEP302 loader cannot find the source\n                        # for this module.\n                        return []\n                    cache[filename] = (\n                        len(data),\n                        None,\n                        [line + '\\n' for line in data.splitlines()],\n                        fullname\n                    )\n                    return cache[filename][2]\n    \n            # Try looking through the module search path, which is only useful\n            # when handling a relative filename.\n            if os.path.isabs(filename):\n                return []\n    \n            for dirname in sys.path:\n                try:\n                    fullname = os.path.join(dirname, basename)\n                except (TypeError, AttributeError):\n                    # Not sufficiently string-like to do anything useful with.\n                    continue\n                try:\n                    stat = os.stat(fullname)\n                    break\n                except OSError:\n                    pass\n            else:\n                return []\n        try:\n>           with tokenize.open(fullname) as fp:\nE           RecursionError: maximum recursion depth exceeded\n\n..\\..\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\linecache.py:136: RecursionError\n\nDuring handling of the above exception, another exception occurred:\n\npages = <web_pages.UIWorkerWeb object at 0x000002A44807BD70>\n\n    @pytest.fixture(scope='function')\n    def login(pages):\n        \"\"\" Войти в аккаунт \"\"\"\n>       pages.login()\n\nconftest.py:41: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nweb_pages\\auth_user_page.py:31: in login\n    self.set_email_field(PersonData.user_login)\nweb_pages\\auth_user_page.py:14: in set_email_field\n    self.wait_for_element_to_be_clickable(AuthLoginLocators.EMAIL_FIELD)\nweb_pages\\base_page.py:64: in wait_for_element_to_be_clickable\n    BasePage.wait_for_element_to_be_clickable(self, locator)\nweb_pages\\base_page.py:64: in wait_for_element_to_be_clickable\n    BasePage.wait_for_element_to_be_clickable(self, locator)\nE   RecursionError: maximum recursion depth exceeded\n!!! Recursion detected (same locals & position)"}, "description": "При нажатии на кнопку ЛК - переход на страницу профиля ", "parameters": [{"name": "driver_do", "value": "'chrome'"}], "start": 1721365047086, "stop": 1721365047086, "uuid": "eaebd793-870f-446c-af73-ead32cd3bba3", "historyId": "4490d967797ae88472b845824fd80932", "testCaseId": "7a1a862c6da3a7995d86494c53393b5d", "fullName": "tests.test_lk.TestLKProfile#test_go_to_account_from_header", "labels": [{"name": "parentSuite", "value": "tests"}, {"name": "suite", "value": "test_lk"}, {"name": "subSuite", "value": "TestLKProfile"}, {"name": "host", "value": "DESKTOP-UBJ37DP"}, {"name": "thread", "value": "14948-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "tests.test_lk"}]}